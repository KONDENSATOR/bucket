// Generated by CoffeeScript 1.8.0
(function() {
  var changed, close, commit, discard, dlog, ensure, filename, fork, fs, ilog, inspect, load, merge, oblit, onclosed, onerr, onlisted, onoblited, onread, onstored, path, readline, remove, set, store, util, _;

  path = require("path");

  fs = require("fs");

  readline = require("readline");

  _ = require("lodash");

  util = require("util");

  dlog = function(obj, fname) {};

  ilog = function(obj, fname, info) {
    return console.log(obj.state.id, fname, info);
  };

  inspect = function(obj, value) {
    dlog(obj, "inspect");
    console.log(util.inspect(value, {
      colors: true,
      depth: null
    }));
    return obj;
  };

  set = function(obj, items) {
    var state;
    dlog(obj, "set");
    if (items != null) {
      state = obj.state;
      if (!_.isArray(items)) {
        items = [items];
      }
      ilog(obj, "set", "Set argument contains " + items.length + " items");
      _.each(items, function(item) {
        var comparable, present;
        if (item.id == null) {
          discard(obj);
          state.err("Bucket(" + state.branch + ") Transaction rollbacked - Error: Item contains no id: " + (util.inspect(item)));
          return;
        }
        present = JSON.stringify(state.dirty[item.id]);
        comparable = JSON.stringify(item);
        if (present !== comparable) {
          state.dirty[item.id] = item;
          return state.changes[item.id] = item;
        }
      });
    }
    return obj;
  };

  remove = function(obj, ids) {
    var state;
    dlog(obj, "remove");
    if (ids != null) {
      if (!_.isArray(ids)) {
        ids = [ids];
      }
      state = obj.state;
      _.each(ids, function(id) {
        delete state.dirty[id];
        return state.changes[id] = {
          id: id,
          deleted: true
        };
      });
    }
    return obj;
  };

  filename = function(obj) {
    var state;
    dlog(obj, "filename");
    state = obj.state;
    return path.join(state.path, state.branch);
  };

  load = function(obj, fn) {
    dlog(obj, "load");
    return (function(obj, fn) {
      var rl, state;
      state = obj.state;
      fs.closeSync(fs.openSync(filename(obj), 'a'));
      rl = readline.createInterface({
        input: fs.createReadStream(filename(obj)),
        output: process.stdout,
        terminal: false
      });
      rl.on("line", (function(_this) {
        return function(line) {
          var chunk;
          chunk = JSON.parse(line);
          return set(obj, chunk);
        };
      })(this));
      rl.on("close", (function(_this) {
        return function() {
          var changes;
          changes = obj.state.changes;
          commit(obj);
          obj.state.read(obj, changes);
          changes = null;
          if (fn != null) {
            return fn(obj);
          }
        };
      })(this));
      return obj;
    })(obj, fn);
  };

  oblit = function(obj) {
    var state;
    dlog(obj, "oblit");
    state = obj.state;
    return obj;
  };

  close = function(obj) {
    var state;
    dlog(obj, "close");
    state = obj.state;
    return obj;
  };

  fork = function(obj, name) {
    var state;
    dlog(obj, "fork");
    state = obj.state;
    return obj;
  };

  merge = function(obj) {
    var state;
    dlog(obj, "merge");
    state = obj.state;
    return obj;
  };

  changed = function(obj) {
    dlog(obj, "changed");
    return _.keys(obj.state.changes).length > 0;
  };

  discard = function(obj) {
    var state;
    dlog(obj, "discard");
    state = obj.state;
    state.dirty = _.clone(state.commited);
    state.changes = {};
    return obj;
  };

  commit = function(obj) {
    var changes, state;
    dlog(obj, "commit");
    state = obj.state;
    changes = state.changes;
    state.commited = _.clone(state.dirty);
    state.changes = {};
    return obj;
  };

  store = function(obj) {
    dlog(obj, "store");
    return (function(obj) {
      var state, transaction;
      state = obj.state;
      if (!changed(obj)) {
        ilog(obj, "store", "Nothing changed");
      } else {
        transaction = JSON.stringify(_(state.changes).values()) + "\n";
        ilog(obj, "store", "Appending to " + (filename(obj)));
        fs.appendFile(filename(obj), transaction, {
          encoding: 'utf8'
        }, function(err) {
          var stored_changes;
          if (err != null) {
            discard(obj);
            ilog(obj, "store", "Error storing");
            return state.err(("Bucket(" + this.state.branch + ") Transaction rollbacked - ") + err);
          } else {
            ilog(obj, "store", "Done storing " + state.changes.length + " changes");
            stored_changes = state.changes;
            commit(obj);
            state.stored(obj, stored_changes);
            return stored_changes = null;
          }
        });
      }
      return obj;
    })(obj);
  };

  ensure = function(filepath, fn) {
    return (function(filepath, fn) {
      var real;
      real = path.resolve(filepath);
      return fs.exists(real, function(exists) {
        if (exists) {
          return fn();
        } else {
          return fn("Path '" + real + "' does not exist");
        }
      });
    })(filepath, fn);
  };

  onerr = function(obj, fn) {
    dlog(obj, "onerr");
    obj.state.err = fn;
    return this;
  };

  onread = function(obj, fn) {
    dlog(obj, "onread");
    obj.state.read = fn;
    return this;
  };

  onstored = function(obj, fn) {
    dlog(obj, "onstored");
    obj.state.stored = fn;
    return this;
  };

  onoblited = function(obj, fn) {
    dlog(obj, "onoblited");
    obj.state.oblited = fn;
    return this;
  };

  onlisted = function(obj, fn) {
    dlog(obj, "onlisted");
    obj.state.listed = fn;
    return this;
  };

  onclosed = function(obj, fn) {
    dlog(obj, "onclosed");
    obj.state.closed = fn;
    return this;
  };

  module.exports = {
    inspect: inspect,
    set: set,
    remove: remove,
    filename: filename,
    load: load,
    oblit: oblit,
    close: close,
    fork: fork,
    merge: merge,
    changed: changed,
    discard: discard,
    store: store,
    ensure: ensure,
    onerr: onerr,
    onread: onread,
    onstored: onstored
  };

}).call(this);
